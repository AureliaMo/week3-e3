---
title: "week3-E3"
author: "AureliaMo"
date: "2023-05-05"
output: html_document
---

## Exercise 3

libraries
```{r}
library(readr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(lubridate)

library(sf)
library(tmap)
```

## Preparation

import data and transform it to the coordinate system. 

```{r}
mydata <- read_delim("aurelia_dataset.csv", delim = ";")

# create datetime column
mydata <- mydata |> 
  mutate(Time = as.character(Time),
         datetime = paste(Date,Time),
         datetime = as.POSIXct(datetime, format = "%d.%m.%Y %X", tz="UTC"),
         datetime = with_tz(datetime, tzone = "Europe/Berlin")
         ) |> 
  select(datetime, Latitude, Longitude)

# convert data to an sf object
mydata <- st_as_sf(mydata, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE) # EPSG code for WGS84 = 4326

# convert data to coordinate system CH1903+ LV95
mydata <- st_transform(mydata, crs = 2056) 

head(mydata)
```

store the coordinates in separate columns, explore Data and filter the day i cycled to Waedenswil

```{r}
# store the coordinates in separate columns
mycoord <- st_coordinates(mydata)

mydata <- cbind(mydata, mycoord)

# explore Data
tmap_mode("view")
tm_shape(mydata)+
  tm_dots()

# choose a single day for the next steps 

oneday <- mydata |> 
  filter(as.Date(datetime) == "2023-04-06")

head(oneday)
tm_shape(oneday)+
  tm_dots()
```


## Task 1 Segmentation

Step a): Specify a temporal window 
I was riding my bike and the sampling interval was 5 seconds. If i didn't move for more than 20 secs, i probably waited at a red light, or for my friends to join me, or to check where i hat do go. So i set my temporal window to 20 secs and therefore to four fixes

 pos[n-2] to pos[n]
 pos[n-1] to pos[n]
 pos[n] to pos[n+1]
 pos[n] to pos[n+2]



Step b): Measure the distance from every point to every other point within this temporal window. Calculate the mean distance between the points. 

```{r}

oneday <- oneday |> 
  mutate(
    n_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    n_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    n_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    n_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2)
  )

oneday <- oneday |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    stepmean = mean(c(n_plus1, n_plus2, n_minus1, n_minus2))
  ) |> 
  ungroup() # otherwise each row would represent a group, we don't want that

```

## Task 2: Specify and apply threshold d

exploring the euclidean distance values. how is the distribution? 
```{r}

ggplot(oneday, aes(stepmean))+
  geom_histogram(binwidth = 5)+
  geom_vline(xintercept = mean(oneday$stepmean, na.rm=TRUE))

# the distribution shows two peaks. one at lower mean steplength (5 m) and one around mean steplengths of 50m. Segmenting by the mean of the values seems reasonable. 

```

We use the mean of all stepmean values to separate moves from static points. Store the new information (boolean to differentiate between stops (TRUE) and moves (FALSE)) in a new column named static.

````{r}
oneday <- oneday |> 
  mutate(static = stepmean < mean(stepmean, na.rm = TRUE)) 

```


## Task 3: Visualize segmented trajectories

```{r}
ggplot(oneday, aes(X, Y))+
  geom_path()+
  geom_point(aes(color = static))+
  coord_fixed()
```

I walked the last bit from Waedenswil bahnhof to the campus, and there were some steep parts on the way to Oerlikon, where i moved slower. Also, I stopped sometimes to check the directions and wait for my friends. The visualisation represents my stops adequately i think.


## Task 4 Segment-based analysis

assign unique IDs to the segments

```{r}
# function for assigning unique ID to the subtrajectories

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

oneday <- oneday |> 
  mutate(ID=rle_id(static))

head(oneday)
```

Visualize the moving segments by colourizing them by segment_ID.
```{r}

oneday <- oneday |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

head(oneday)

ggplot(oneday, aes(X, Y))+
  geom_point()+
  geom_path(aes(color=ID))+
  coord_fixed()

# gosh, i have many different segments!
```

Use segment_ID as a grouping variable to determine the segments duration and remove short segments (e.g. segments with a duration < 5 Minutes)

```{r}
oneday |>
  
  
as.numeric(difftime(oneday$datetime[1], oneday$datetime[length(datetime)]))

head(oneday)

```


